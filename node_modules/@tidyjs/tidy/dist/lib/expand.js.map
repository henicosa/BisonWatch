{"version":3,"file":"expand.js","sources":["../../src/expand.ts"],"sourcesContent":["import { A, O } from 'ts-toolbelt';\nimport { SingleOrArray } from './helpers/singleOrArray';\nimport { Key, TidyFn } from './types';\n\n// helper types\nexport type KeyMap<T extends object = any> = Partial<\n  {\n    [key in keyof T]: keyof T | Array<T[key]> | ((items: T[]) => T[key][]);\n  }\n>;\n\n/**\n * Expands a set of items to include all combinations of the specified keys.\n */\n// prettier-ignore\nexport function expand<T extends object = any, K extends keyof T = keyof T>(expandKeys: K): TidyFn<T, A.Compute<Pick<T, K>>>;\n// prettier-ignore\nexport function expand<T extends object = any, K extends (keyof T)[] = (keyof T)[]>(expandKeys: K): TidyFn<T, A.Compute<Pick<T, K[number]>>>;\n// prettier-ignore\nexport function expand<T extends object = any, K extends KeyMap<T> = KeyMap<T>>(expandKeys: K): TidyFn<T, O.Pick<T, keyof K>>\n// prettier-ignore\nexport function expand<T extends object>(expandKeys: SingleOrArray<Key> | KeyMap<T>): TidyFn<T> {\n  const _expand: TidyFn<T> = (items: T[]) => {\n    const keyMap = makeKeyMap(expandKeys);\n\n    // for each key, get all distinct values or use the provided values\n    const vectors = [];\n    for (const key in keyMap) {\n      const keyValue = keyMap[key];\n      let values;\n      if (typeof keyValue === 'function') {\n        values = keyValue(items);\n      } else if (Array.isArray(keyValue)) {\n        values = keyValue;\n      } else {\n        // read distinct values from the key in the data\n        values = Array.from(new Set(items.map((d) => d[key as keyof T])));\n      }\n\n      vectors.push(values.map((value: any) => ({ [key]: value })));\n    }\n\n    // make all combinations of all value sets\n    return makeCombinations(vectors);\n  };\n\n  return _expand;\n}\n\n/*\n  Recursively compute key combinations\n*/\nfunction makeCombinations(vectors: any[][]): any[] {\n  function combine(accum: any[], baseObj: any, remainingVectors: any[][]) {\n    if (!remainingVectors.length && baseObj != null) {\n      accum.push(baseObj);\n      return;\n    }\n\n    const vector = remainingVectors[0];\n    const newRemainingArrays = remainingVectors.slice(1);\n    for (const item of vector) {\n      combine(accum, { ...baseObj, ...item }, newRemainingArrays);\n    }\n  }\n\n  const result: any[] = [];\n  combine(result, null, vectors);\n  return result;\n}\n\n// convert by option in to a map from T key to JoinT key\nexport function makeKeyMap(keys: SingleOrArray<Key> | KeyMap): KeyMap {\n  if (Array.isArray(keys)) {\n    const keyMap: KeyMap = {};\n    for (const key of keys) {\n      keyMap[key as any] = key;\n    }\n    return keyMap;\n  } else if (typeof keys === 'object') {\n    return keys;\n  }\n\n  return { [keys]: keys as any } as KeyMap;\n}\n"],"names":[],"mappings":";;;;gBAqByC;AACvC,QAAM,UAAqB,CAAC;AAC1B,UAAM,SAAS,WAAW;AAG1B,UAAM,UAAU;AAChB,eAAW,OAAO;AAChB,YAAM,WAAW,OAAO;AACxB,UAAI;AACJ,UAAI,OAAO,aAAa;AACtB,iBAAS,SAAS;AAAA,iBACT,MAAM,QAAQ;AACvB,iBAAS;AAAA;AAGT,iBAAS,MAAM,KAAK,IAAI,IAAI,MAAM,IAAI,CAAC,MAAM,EAAE;AAAA;AAGjD,cAAQ,KAAK,OAAO,IAAI,CAAC,aAAmB,MAAM;AAAA;AAIpD,WAAO,iBAAiB;AAAA;AAG1B,SAAO;AAAA;AAMT,0BAA0B;AACxB,mBAAiB,OAAc,SAAc;AAC3C,QAAI,CAAC,iBAAiB,UAAU,WAAW;AACzC,YAAM,KAAK;AACX;AAAA;AAGF,UAAM,SAAS,iBAAiB;AAChC,UAAM,qBAAqB,iBAAiB,MAAM;AAClD,eAAW,QAAQ;AACjB,cAAQ,OAAO,IAAK,YAAY,OAAQ;AAAA;AAAA;AAI5C,QAAM,SAAgB;AACtB,UAAQ,QAAQ,MAAM;AACtB,SAAO;AAAA;oBAIkB;AACzB,MAAI,MAAM,QAAQ;AAChB,UAAM,SAAiB;AACvB,eAAW,OAAO;AAChB,aAAO,OAAc;AAAA;AAEvB,WAAO;AAAA,aACE,OAAO,SAAS;AACzB,WAAO;AAAA;AAGT,SAAO,EAAG,OAAO;AAAA;;;;;"}