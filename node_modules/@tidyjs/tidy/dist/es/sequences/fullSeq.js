import { extent } from 'd3-array';

function vectorSeq(values, period = 1) {
  let [min, max] = extent(values);
  const sequence = [];
  let value = min;
  while (value <= max) {
    sequence.push(value);
    value += period;
  }
  return sequence;
}
function vectorSeqDate(values, granularity = "day", period = 1) {
  let [min, max] = extent(values);
  const sequence = [];
  let value = new Date(min);
  while (value <= max) {
    sequence.push(new Date(value));
    if (granularity === "second" || granularity === "s" || granularity === "seconds") {
      value.setUTCSeconds(value.getUTCSeconds() + 1 * period);
    } else if (granularity === "minute" || granularity === "min" || granularity === "minutes") {
      value.setUTCMinutes(value.getUTCMinutes() + 1 * period);
    } else if (granularity === "day" || granularity === "d" || granularity === "days") {
      value.setUTCDate(value.getUTCDate() + 1 * period);
    } else if (granularity === "week" || granularity === "w" || granularity === "weeks") {
      value.setUTCDate(value.getUTCDate() + 7 * period);
    } else if (granularity === "month" || granularity === "m" || granularity === "months") {
      value.setUTCMonth(value.getUTCMonth() + 1 * period);
    } else if (granularity === "year" || granularity === "y" || granularity === "years") {
      value.setUTCFullYear(value.getUTCFullYear() + 1 * period);
    } else {
      throw new Error("Invalid granularity for date sequence: " + granularity);
    }
  }
  return sequence;
}
function fullSeq(key, period) {
  return function fullSeqInner(items) {
    period = period != null ? period : 1;
    const keyFn = typeof key === "function" ? key : (d) => d[key];
    return vectorSeq(items.map(keyFn), period);
  };
}
function fullSeqDate(key, granularity, period) {
  return function fullSeqDateInner(items) {
    granularity = granularity != null ? granularity : "day";
    period = period != null ? period : 1;
    const keyFn = typeof key === "function" ? key : (d) => d[key];
    return vectorSeqDate(items.map(keyFn), granularity, period);
  };
}
function fullSeqDateISOString(key, granularity, period) {
  return function fullSeqDateISOStringInner(items) {
    granularity = granularity != null ? granularity : "day";
    period = period != null ? period : 1;
    const keyFn = typeof key === "function" ? key : (d) => d[key];
    return vectorSeqDate(items.map((d) => new Date(keyFn(d))), granularity, period).map((date) => date.toISOString());
  };
}

export { fullSeq, fullSeqDate, fullSeqDateISOString, vectorSeq, vectorSeqDate };
//# sourceMappingURL=fullSeq.js.map
